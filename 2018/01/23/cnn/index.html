<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 卷积神经网络学习笔记 · Colorjam's Blog</title><meta name="description" content="卷积神经网络学习笔记 - Colorjam"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Colorjam's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/pinkladies" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">卷积神经网络学习笔记</h1><div class="post-info">Jan 23, 2018</div><div class="post-content"><p>卷积神经网络和普通的神经网络很相似，但是明确表示了输入是图像，并且允许我们编码一些特征，因此就使得提升了网络前向传播的效率，并且大大减少了网络中的参数。下面就让我们一起瞅瞅CNN加入了哪些神奇的东西吧 :)</p>
<a id="more"></a>
<blockquote>
<p>A ConvNet is made up of Layers. Every Layer has a simple API: It transforms an input 3D volume to an output 3D volume with some differentiable function that may or may not have parameters.</p>
</blockquote>
<p>上面这句话透露了很多有意思的东西，包括<strong>3D volume</strong>、<strong>Layers</strong>、<strong>Parameters</strong>，让我们一个个来说说～</p>
<h3 id="3D-volume"><a href="#3D-volume" class="headerlink" title="3D volume"></a>3D volume</h3><p>普通的神经网络将输入图像排列成一个向量，通过和对应数量的参数点乘获得预测结果：</p>
<p><img src="/2018/01/23/cnn/fc_layer.png" alt=""></p>
<p>但CNN保留了输入图像的空间结构，将其看作是3维（<strong>width, height, depth</strong>）结构的，并利用较少的参数过滤映射出下一层：</p>
<p><img src="/2018/01/23/cnn/cn_layer.png" alt=""></p>
<h3 id="Layers"><a href="#Layers" class="headerlink" title="Layers"></a>Layers</h3><p>我们主要使用三种类型的层来构建卷积神经网络，分别是：<strong>卷积层（Convolutional Layer）</strong>、<strong>汇聚层（ Pooling Layer）</strong>、和<strong>全连接层（Fully-Connected Layer）</strong></p>
<h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>卷积层是构建卷积神经网络的核心层。卷积层的参数是由一些可学习的滤波器集合（参数）构成的。每个滤波器在空间上（宽度和高度）都比较小，但是深度和输入数据一致。</p>
<p><strong>局部连接</strong>：我们已经知道全连接需要与对应数量的参数点乘，但这对于大尺寸的图像来说运算量是非常大的。因此我们让每个神经元只与输入数据的一个局部区域连接。该连接的空间大小叫做神经元的<strong>感受野（receptive field）</strong>。它的尺寸其实就是滤波器的空间尺寸。</p>
<p>❗️我们让在滤波器在宽度和高度上滑动，但总是让滤波器的深度=输入数据深度。</p>
<p><strong>空间排列</strong>：有了输入和参数，我们应该就可以得到输出了。但这里还要提一下3个控制输出数据尺寸的超参数：<strong>深度（depth），步长（stride）</strong>和<strong>零填充（zero-padding）</strong>。</p>
<ol>
<li><p>此深度非彼深度。上面我们提到了输入数据的深度，现在这个输出数据的深度其实是使用的<strong>滤波器数量</strong>。</p>
<p><img src="/2018/01/23/cnn/maps.png" alt=""></p>
</li>
<li><p>在滑动滤波器的时候我们要指定每次移动多少个像素，也就是步长。</p>
<p>假设使用3x3滤波器在[7x7]的输入数据上滑动 =&gt; [5x5]的输出数据，而使用2个步长滑动，会让输出数据在空间上变小 =&gt; [3x3]的输出数据</p>
</li>
<li><p>有时候会用0在输入数据体的边缘处进行填充，可以让输出数据与输入数据空间保持一致。</p>
<p><img src="/2018/01/23/cnn/zero_padding.png" alt=""></p>
</li>
</ol>
<p>我们就可以通过输入数据尺寸\(W_1\timeslH_1\timesD1)\\、滤波器尺寸（F）、步长（S）和零填充的数量（P），计算出输出数据的空间尺寸：(W-F+2P)/S+1</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/01/21/neural-nets-note/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Colorjam</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>