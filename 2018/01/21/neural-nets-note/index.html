<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 神经网络方法小结 · Colorjam's Blog</title><meta name="description" content="神经网络方法小结 - Colorjam"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Colorjam's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/pinkladies" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">神经网络方法小结</h1><div class="post-info">Jan 21, 2018</div><div class="post-content"><p>在cs231n上学习了关于神经网络一系列数据处理、参数训练、结果分析的方法，为加深印象做一些整理。</p>
<a id="more"></a>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>机器学习本质上是数据工程，数据的分布对于算法学习过程是有影响的。所以在整个学习开始前，需要对<strong>原始数据</strong>进行预处理。通常的方法有：</p>
<ul>
<li><p><strong>均值减法（Mean subtraction）</strong>：使数据零均值化<code> X -= np.mean(X)</code></p>
</li>
<li><p><strong>归一化（Normalization）</strong>：使数据范围近似相等<code>X /= np.std(X, axis=0)</code></p>
<p><img src="/2018/01/21/neural-nets-note/data_preprocessing1.jpeg" alt=""></p>
</li>
<li><p><strong>主成分分析（Principal Component Analysis，PCA）</strong>：降低数据维度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">X -= np.mean(X, axis = <span class="number">0</span>) <span class="comment"># 对数据进行零中心化(重要)</span></div><div class="line">cov = np.dot(X.T, X) / X.shape[<span class="number">0</span>] <span class="comment"># 得到数据的协方差矩阵</span></div><div class="line">U,S,V = np.linalg.svd(cov) <span class="comment"># 奇异值分解</span></div><div class="line">Xrot = np.dot(X,U) <span class="comment"># 对数据去相关性</span></div><div class="line">Xrot_reduced = np.dot(X, U[:,:<span class="number">100</span>]) <span class="comment"># 降维</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>白化（Whitening）</strong>：降低数据的冗余度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 除以特征值 </span></div><div class="line">Xwhite = Xrot / np.sqrt(S + <span class="number">1e-5</span>)</div></pre></td></tr></table></figure>
<p><img src="/2018/01/21/neural-nets-note/data_preprocessing2.jpeg" alt=""></p>
</li>
</ul>
<p>❗️在进行预处理的过程中，对所有数据统一处理后再划分训练集/验证集/测试集的做法是<strong>错误的</strong>。正确做法是：先将数据划分为训练集/验证集/测试集，对<strong>训练集</strong>进行操作后，将其运用于验证集和测试集。</p>
<h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p>除了数据X，神经网络还有一些很重要的数值就是<strong>权重W</strong>和<strong>偏置b</strong>。</p>
<p><strong>初始化权重</strong>有以下几种方法：</p>
<ul>
<li><p><strong>小随机数初始化</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">W = <span class="number">0.01</span> * np.random.randn(D,H)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>使用1/sqrt(n)校准方差</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">W = np.random.randn(n) / sqrt(n)</div><div class="line">W = np.random.randn(n) * sqrt(<span class="number">2.0</span>/n) <span class="comment"># ReLU神经元的特殊初始化</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>稀疏初始化（Sparse initialization）</strong></p>
</li>
</ul>
<p><strong>初始化偏置</strong>：通常初始为全0。</p>
<h3 id="损失函数（Loss-Functions）"><a href="#损失函数（Loss-Functions）" class="headerlink" title="损失函数（Loss Functions）"></a>损失函数（Loss Functions）</h3><p><strong>数据损失</strong>是一个有监督学习问题，用于衡量分类算法的预测结果和真实标签结果的一致性。我们要计算所有样本的平均数据损失，向减小这个数值的方向不断努力。可以说这就是深度学习的根本目的了。因此也就产生了一系列计算数据损失的损失函数：</p>
<ul>
<li><p><strong>Multiclass Support Vector Machine loss（SVM）</strong>：SVM分类器的损失函数想要SVM在正确分类的得分比不正确分类的得分来得高，且至少高出一个边界值𝚫。<br>$$<br>L_i = \sum_{j\neq y_i} \max(0, s_j - s_{y_i} + \Delta)<br>$$<br>这里要提一下<strong>折页损失（hinge loss）</strong>，即\(max(0, —)\)函数，它常用于“maximum-margin”的算法。因为SVM分类器就属于这类算法，所以我们用名称SVM来代表这类损失函数。</p>
</li>
<li><p><strong>Softmax</strong>：Softmax分类器将评分值视为每个分类的未归一化的对数概率（\(e^{f_{y_{i}}}\)，把折页损失替换成了<strong>交叉熵损失（cross-entropy loss）</strong>，它所做的就是最小化在估计分类概率和“真实”分布之间的交叉熵：<br>$$<br>L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right)<br>$$</p>
</li>
</ul>
<p>❗️在实际编程实现Softmax的过程中，中间项 \(e^{f_{y_i}}\) 和 \(\sum_j e^{f_j}\) 因为存在指数函数，数值可能非常大。除以大数值可能导致数值计算的不稳定，所以学会使用归一化的小技巧非常重要。通常将𝐶设为\(\log C = -\max_j f_j\)<br>$$<br>\frac{e^{f_{y_i}}}{\sum_j e^{f_j}}<br>= \frac{Ce^{f_{y_i}}}{C\sum_j e^{f_j}}<br>= \frac{e^{f_{y_i} + \log C}}{\sum_j e^{f_j + \log C}}<br>$$<br><img src="/2018/01/21/neural-nets-note/svmvssoftmax.png" alt="svmvssoftmax"></p>
<h3 id="正则化（Regularization）"><a href="#正则化（Regularization）" class="headerlink" title="正则化（Regularization）"></a>正则化（Regularization）</h3><p>除了数据损失部分，正则项也是在损失函数很重要的一部分。如果模型太复杂即出现过拟合（overfitting），我们就需要加入一些正则项来解决这个问题。</p>
<ul>
<li><p><strong>L2正则化</strong>：\(R(W) = \sum_k\sum_lW_{k,l}^2\) </p>
</li>
<li><p><strong>L1正则化</strong>：\(R(W) = \sum_k\sum_l|W_{k,l}|\) </p>
</li>
<li><p><strong>最大范式约束（Max norm constraints）</strong>：给每个神经元中权重向量的量级设定上限，并使用投影梯度下降来确保这一约束。</p>
</li>
<li><p><strong>随机失活（Dropout）</strong>：让神经元以超参数𝑝的概率被激活或者被设置为0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p = <span class="number">0.5</span> <span class="comment"># 激活神经元的概率. p值更高 = 随机失活更弱</span></div><div class="line">U1 = (np.random.rand(*H1.shape) &lt; p) / p <span class="comment"># 随机失活遮罩</span></div><div class="line">H1 *= U1 <span class="comment"># drop!</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>批量归一化（Batch Normalization）</strong>：为了使神经网络的每一层输入数据都满足正态分布，除了一开始的数据预处理，科学家们引入了批量归一化。就是在使用每层的激活函数前，对采样的批数据进行归一化处理。</p>
</li>
</ul>
<p>❗️在开始最优化前我们最好做一些<strong>合理性检查</strong>：</p>
<ul>
<li>寻找特定情况的正确损失值</li>
<li>提高正则化强度时导致损失值变大</li>
<li>对小数据子集过拟合</li>
</ul>
<h3 id="最优化（Optimization）"><a href="#最优化（Optimization）" class="headerlink" title="最优化（Optimization）"></a>最优化（Optimization）</h3><p>机器学习的过程不断修改权重W，使Loss能够减小。最常见的方法就是进行<strong>反向传播（Backpropagation）</strong>。通过微分公式和链式法则计算出<strong>解析梯度</strong>，沿着梯度的负方向更新权重。但解析梯度非常容易算错，所以我们可以计算<strong>数值梯度</strong>来进行<strong>梯度检查</strong>，有两种比较方式：</p>
<ul>
<li><strong>使用中心化公式</strong></li>
</ul>
<p>$$<br>\frac{df(x)}{dx} = \frac{f(x + h) - f(x - h)}{2h} \hspace{0.1in}<br>$$</p>
<ul>
<li><strong>使用相对误差</strong><br>$$<br>\frac{\mid f’_a - f’_n \mid}{\max(\mid f’_a \mid, \mid f’_n \mid)}<br>$$</li>
</ul>
<p>不断迭代计算梯度并更新权重的最优化方法就是<strong>梯度下降法（Gradient descent）</strong>。迭代的思路主要有两种：</p>
<ul>
<li><strong>批量梯度下降（Batch Gradient Descent，BGD）</strong>：每次使用所有数据计算梯度</li>
<li><strong>随机梯度下降（Stochastic Gradient Descent，SGD）</strong>：每次只使用一个数据计算梯度</li>
<li><strong>小批量数据梯度下降（Mini-batch gradient descent）</strong>：每次使用一个小批量数据计算</li>
</ul>
<p>❗️即使SGD在技术上是指每次使用1个数据来计算梯度，但人们会使用SGD来指代小批量数据梯度下降</p>
<p>因为深度学习的参数通常处于高维空间，不同的更新方法会导致不同的优化速度。</p>
<ul>
<li><p><strong>普通更新</strong>：沿着负梯度方向改变参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x += - learning_rate * dx</div></pre></td></tr></table></figure>
</li>
<li><p><strong>动量更新</strong>：从物理角度出发，负梯度与质点的加速度是成比例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v = mu * v - learning_rate * dx <span class="comment"># 与速度融合</span></div><div class="line">x += v <span class="comment"># 与位置融合</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>Nesterov动量</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v_prev = v <span class="comment"># 存储备份</span></div><div class="line">v = mu * v - learning_rate * dx <span class="comment"># 速度更新保持不变</span></div><div class="line">x += -mu * v_prev + (<span class="number">1</span> + mu) * v <span class="comment"># 位置更新变了形式</span></div></pre></td></tr></table></figure>
<p><img src="/2018/01/21/neural-nets-note/gradientdescent.png" alt="loss"></p>
<p>​</p>
</li>
</ul>
<p>第二类常用的最优化方法是基于牛顿法的。在这些方法中最流行的是<strong>L-BFGS</strong>。但在深度学习和卷积神经网络中，使用L-BFGS之类的二阶方法并不常见。相反，基于（Nesterov的）动量更新的各种随机梯度下降方法更加常用，因为它们更加简单且容易扩展。</p>
<p>上面这些更新方法都是对学习率进行全局地操作，并且对所有的参数都是一样的。因此就有人提出了适应性学习率算法：</p>
<ul>
<li><p><strong>Adagrad</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cache += dx**<span class="number">2</span></div><div class="line">x += - learning_rate * dx / (np.sqrt(cache) + eps)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>RMSprop</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cache =  decay_rate * cache + (<span class="number">1</span> - decay_rate) * dx**<span class="number">2</span></div><div class="line">x += - learning_rate * dx / (np.sqrt(cache) + eps)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Adam</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">m = beta1*m + (<span class="number">1</span>-beta1)*dx</div><div class="line">v = beta2*v + (<span class="number">1</span>-beta2)*(dx**<span class="number">2</span>)</div><div class="line">x += - learning_rate * m / (np.sqrt(v) + eps)</div></pre></td></tr></table></figure>
<p><img src="/2018/01/21/neural-nets-note/opt2.gif" alt="loss"></p>
</li>
</ul>
<h3 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h3><p>在训练深度网络的时候，让学习率随着时间衰减通常是有帮助的。</p>
<ul>
<li><strong>随步数衰减</strong>：每进行几个周期就根据一些因素降低学习率</li>
<li><strong>指数衰减</strong>：\(\alpha = \alpha_0 e^{-k t})\\</li>
<li><strong>1/t衰减</strong>：\(\alpha = \alpha_0 / (1 + k t ))\\</li>
</ul>
<h3 id="超参数调优"><a href="#超参数调优" class="headerlink" title="超参数调优"></a>超参数调优</h3><p>整个训练过程我们会遇到很多超参数，掌握一些小技巧对于超参数初的始化和调整是必不可少的。</p>
<ul>
<li><strong>超参数范围</strong>：在对数尺度上进行超参数搜索。一个典型的学习率应该看起来是这样：<strong>learning_rate = 10 \</strong> uniform(-6, 1)<strong>。对于正则化强度，可以采用同样的策略。但是有一些参数（比如随机失活）还是在原始尺度上进行搜索（例如：</strong>dropout=uniform(0,1)**）。</li>
<li><strong>随机搜索优于网格搜索</strong>：通常，有些超参数比其余的更重要。通过随机搜索，可以更精确地发现那些比较重要的超参数的好数值。</li>
<li><strong>小心边界上的最优值</strong>：假设我们使用<strong>learning_rate = 10 \</strong> uniform(-6,1)**来进行搜索。一旦我们得到一个比较好的值，一定要确认你的值不是出于这个范围的边界上，不然你可能错过更好的其他搜索范围。</li>
<li><strong>从粗到细地分阶段搜索</strong>：在实践中，先进行初略范围搜索，让模型训练一个周期就可以了；第二个阶段就是根据好结果出现的地方，缩小范围进行搜索，这时可以让模型运行5个周期；最后一个阶段就在最终的范围内进行仔细搜索，运行很多次周期。</li>
<li><strong>贝叶斯超参数最优化</strong>：主要是研究在超参数空间中更高效的导航算法。</li>
</ul>
<h3 id="检查学习过程"><a href="#检查学习过程" class="headerlink" title="检查学习过程"></a>检查学习过程</h3><p>可以通过可视化的方式来检查我们的损失值、精确值等是否符合预期。</p>
<ul>
<li><p><strong>损失值</strong>：损失值的震荡程度和批尺寸（batch size）有关，当批尺寸为1，震荡会相对较大。当批尺寸就是整个数据集时，震荡就会最小。</p>
<p><img src="/2018/01/21/neural-nets-note/loss.png" alt="loss"></p>
<p>​</p>
</li>
<li><p><strong>训练集和测试集的准确率</strong>：在训练集准确率和验证集准确率中间的空隙指明了模型过拟合的程度</p>
<p><img src="/2018/01/21/neural-nets-note/accuracies.jpeg" alt="accuracies"> </p>
</li>
<li><p><strong>权重更新比例</strong>：权重中更新值的数量和全部值的数量之间的比例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 假设参数向量为W，其梯度向量为dW</span></div><div class="line">param_scale = np.linalg.norm(W.ravel())</div><div class="line">update = -learning_rate*dW <span class="comment"># 简单SGD更新</span></div><div class="line">update_scale = np.linalg.norm(update.ravel())</div><div class="line">W += update <span class="comment"># 实际更新</span></div><div class="line"><span class="keyword">print</span> update_scale / param_scale <span class="comment"># 要得到1e-3左右</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>每层的激活数据及梯度分布</strong>：可以输出网络中所有层的激活数据和梯度分布的柱状图。如果看到任何奇怪的分布情况，那都不是好兆头。</p>
</li>
<li><p><strong>权重可视化</strong>：如果数据是图像像素数据，可以对第一层权重进行可视化，观察特征分布。</p>
<p><img src="/2018/01/21/neural-nets-note/firstlayer.png" alt="accuracies"></p>
</li>
</ul>
<h3 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h3><p>有时候单个模型并不能满足需求，可以进行模型集成来获得额外的性能提高。进行集成有以下几种方法：</p>
<ul>
<li><strong>同一个模型，不同的初始化</strong>：使用交叉验证来得到最好的超参数，然后用最好的参数来训练不同初始化条件的模型。</li>
<li><strong>在交叉验证中发现最好的模型</strong>：使用交叉验证来得到最好的超参数，然后取其中最好的几个（比如10个）模型来进行集成。</li>
<li><strong>一个模型设置多个记录点</strong>：如果训练非常耗时，那就在不同的训练时间对网络留下记录点（比如每个周期结束），然后用它们来进行模型集成。</li>
<li><strong>在训练的时候跑参数的平均值</strong>：在训练过程中，如果损失值相较于前一次权重出现指数下降时，就在内存中对网络的权重进行一个备份。</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><p><a href="http://cs231n.github.io/neural-networks-2/" target="_blank" rel="external">http://cs231n.github.io/neural-networks-2/</a></p>
</li>
<li><p><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="external">http://cs231n.github.io/neural-networks-3/</a></p>
</li>
<li><p><a href="http://cs231n.github.io/linear-classify/" target="_blank" rel="external">Loss function</a></p>
<p>​</p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/01/23/cnn/" class="prev">PREV</a><a href="/2018/01/19/FullyConnectedNets-train/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Colorjam</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>