<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> d3-studynotes-1 · Colorjam's Blog</title><meta name="description" content="d3-studynotes-1 - Colorjam"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Colorjam's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/pinkladies" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">d3-studynotes-1</h1><div class="post-info">Jul 10, 2017</div><div class="post-content"><p>学习d3的时候遇到的第一个费解的问题是，为什么是先选择一些不存在的元素然后才创建？根据作者2012年写的文章 <a href="https://bost.ocks.org/mike/join/" target="_blank" rel="external">Thinking withe joins</a>，来理解一下数据连接。</p>
<blockquote>
<p>Instead of telling D3 <em>how</em> to do something, tell D3 <em>what</em> you want. You want the circle elements to correspond to data. You want one circle per datum. Instead of instructing D3 to create circles, then, tell D3 that the selection <code>&quot;circle&quot;</code> should correspond to data. This concept is called the <em>data join</em>:</p>
</blockquote>
<p>告诉D3你想要什么而不是怎么做。你想要一个圆形的元素来代表一个数据，不要告诉D3创建一个圆形，告诉D3你要选择一个圆形来代表这个数据。这个概念便叫做数据连接：</p>
<img src="/2017/07/10/d3-studynotes-1/datajoin.png" alt="datajoin.png" title="">
<blockquote>
<p>Data points joined to existing elements produce the <em>update</em> (inner) selection. Leftover unbound data produce the <em>enter</em> selection (left), which represents missing elements. Likewise, any remaining unbound elements produce the <em>exit</em> selection (right), which represents elements to be removed.</p>
</blockquote>
<p>连接数据到已存在的元素产生 <em>更新(update)</em> 选择，未绑定的数据产生 <em>进入(enter)</em> 选择选择，表示数据缺少装它的元素。未绑定的元素产生<em>退出(exit)</em> 选择，表示元素将会被删除。大致理解了三个状态。</p>
<p>但是最新的v4还有一个很迷的函数 <a href="https://github.com/d3/d3-selection#selection_merge" target="_blank" rel="external">selection.merge</a> 需要理解，顺藤摸瓜看到作者关于 <em>merge</em> 的回答，并用3中方法改了一个例子，好强 <a href="https://github.com/d3/d3-selection/issues/86" target="_blank" rel="external">https://github.com/d3/d3-selection/issues/86</a></p>
<p>结合 <a href="https://github.com/d3/d3-selection#selection_data" target="_blank" rel="external">selection_data</a> 中的代码理解一下整个过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> circle = svg.selectAll(<span class="string">"circle"</span>) <span class="comment">// 1</span></div><div class="line">  .data(data) <span class="comment">// 2</span></div><div class="line">    .style(<span class="string">"fill"</span>, <span class="string">"blue"</span>); <span class="comment">// 3</span></div><div class="line"></div><div class="line">circle.exit().remove(); <span class="comment">// 4</span></div><div class="line"></div><div class="line">circle.enter().append(<span class="string">"circle"</span>) <span class="comment">// 5</span></div><div class="line">    .style(<span class="string">"fill"</span>, <span class="string">"green"</span>) <span class="comment">// 6</span></div><div class="line">  .merge(circle) <span class="comment">// 7</span></div><div class="line">    .style(<span class="string">"stroke"</span>, <span class="string">"black"</span>); <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<ol>
<li>选择所有存在的圆。</li>
<li>将这些圆与数据连接，返回匹配的圆：<em>update</em> 选择。</li>
<li>这些更新的圆是蓝色的。</li>
<li>所有不存在的<strong>圆</strong>即不匹配新数据的圆， 通过 <em>exit</em> 选择移除。</li>
<li>为不存在匹配圆的<strong>数据</strong>添加新的圆：<em>enter</em> 选择。</li>
<li>这些进入的圆是绿色的。</li>
<li>产生一个合并进入圆和更新圆的新选择。</li>
<li>这些合并后的圆是黑色的边线。</li>
</ol>
<blockquote>
<p>Thinking with joins means declaring a relationship between a selection (such as <code>&quot;circle&quot;</code>) and data, and then implementing this relationship through the three <em>enter</em>, <em>update</em> and <em>exit</em> states.</p>
</blockquote>
<p>思考连接意味着声明一个选择器（比如圆）和数据的关系，然后通过 <em>enter</em> 、 <em>update</em> 、<em>exit</em> 三个状态来实现这个关系。</p>
<blockquote>
<p>If the new dataset is smaller than the old one, the surplus elements end up in the exit selection and get removed. If the new dataset is larger, the surplus data ends up in the enter selection and new nodes are added. If the new dataset is exactly the same size, then all the elements are simply updated with new positions, and no elements are added or removed.</p>
</blockquote>
<p>如果新的数据器小于旧的，则剩余元素最终会在 <em>exit</em> 选择中被移除；如果新数据集比较大，剩余数据将在输入选择中添加新节点。如果新旧数据集大小相同，则所有元素都将以新的位置进行更新，并且不添加或删除元素。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/07/25/china-map/" class="prev">PREV</a><a href="/2017/07/10/d3-studynotes-2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Colorjam</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><cript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></cript><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>