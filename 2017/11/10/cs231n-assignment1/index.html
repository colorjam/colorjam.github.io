<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> cs231n assignment1 学习笔记 · Colorjam's Blog</title><meta name="description" content="cs231n assignment1 学习笔记 - Colorjam"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Colorjam's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/pinkladies" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">cs231n assignment1 学习笔记</h1><div class="post-info">Nov 10, 2017</div><div class="post-content"><p>作业的运行环境我选择「Working locally」。在配置虚拟环境过程中，果真遇到 matplotlib 运行不了的问题，参考 <a href="https://matplotlib.org/faq/osx_framework.html#osxframework-faq" target="_blank" rel="external">Working with Matplotlib on OSX</a>，除了最后一个，几乎每种方法设置一遍，重启了好几次虚拟环境，最后可以用 jupyter notebook 打开。</p>
<h3 id="k-Nearest-Neighbor-kNN-exercise"><a href="#k-Nearest-Neighbor-kNN-exercise" class="headerlink" title="k-Nearest Neighbor (kNN) exercise"></a>k-Nearest Neighbor (kNN) exercise</h3><p>点击「run」执行每个框框，<code>dists = classifier.compute_distances_two_loops(X_test)</code> 真的要运行非常非常非常久，同时框框左边会左边变成 In [*]，然后我傻傻的以为卡了，重启了好多次，后来才醒悟这是正在运行的意思。</p>
<a id="more"></a>
<p>进行预测的时候发现准确度无论如何都是0.14，查了一下发现 <code>predict_labels</code> 函数没有修改😂 </p>
<p>二次循环的函数比较简单，一次循环边洗澡边思考，然后头脑风暴矩阵变换，开心地想出来了☺️ 核心代码<code>dists[i, :] = np.sqrt(np.sum((X[i, :] - self.X_train) ** 2, axis = 1)).T</code></p>
<p>无循环函数估摸着应该是要运用数学公式来解决。假设测试集(2x3)：<br>$$<br>testX = \begin{pmatrix}x_{11}&amp;x_{12}&amp;x_{13} \\x_{21}&amp;x_{22}&amp;x_{23}\ \end{pmatrix}<br>$$<br>训练集(4x3)：<br>$$<br>trainX = \begin{pmatrix}y_{11}&amp;y_{12}&amp;y_{13} \\y_{21}&amp;y_{22}&amp;y_{23}\\y_{31}&amp;y_{32}&amp;y_{33}\\y_{41}&amp;y_{42}&amp;y_{43}\ \end{pmatrix}<br>$$<br>最后生成 dist (2x4) 的距离矩阵，自然联想到矩阵乘法 (2x4) := (2x3) x (3x4)。刚好代码中也有提示矩阵乘法，那么 \(trainX\) 必然是转置一下的。<br>$$<br>trainX^T = \begin{pmatrix}y_{11}&amp;y_{21}&amp;y_{31}&amp;y_{41} \\y_{12}&amp;y_{22}&amp;y_{32}&amp;y_{42}\\y_{13}&amp;y_{23}&amp;y_{33}&amp;y_{43}\\ \end{pmatrix}<br>$$<br>我们取出一个测试集和一个训练集，计算一下它们的欧氏距离：<br>$$<br>dist[1, 1] = \sqrt{(x_{11}-y_{11})^2 + (x_{12}-y_{12})^2 + (x_{13}-y_{13})^2 }<br>$$<br>我们试一下把每个平方拆开：<br>$$<br>dist[1, 1] = \sqrt{x_{11}^2 - 2x_{11}y_{11}+y_{11}^2 + x_{12}^2 - 2x_{12}y_{12}+y_{12}^2+x_{13}^2 - 2x_{13}y_{13}+y_{13}^2}<br>$$<br>整理出根号里头的家伙：<br>$$<br>x_{11}^2+ x_{12}^2+x_{13}^2 +y_{11}^2+y_{12}^2 +y_{13}^2 - 2(x_{11}y_{11}   +x_{12}y_{12}+ x_{13}y_{13})<br>$$<br>嗯。。。再一次感叹数学之美。。。于是「根号里头的家伙」就被分成了三个部分</p>
<ul>
<li>\(x_{11}^2+ x_{12}^2x_{13}^2\) 相当于 \(testX\) 元素平方，再按列相加，即把矩阵压缩成一列。</li>
<li>\(y_{11}^2+y_{12}^2 +y_{13}^2\) 相当于 \(trainX^T\) 元素平方，再按行相加 ，即把矩阵压缩成一行。</li>
<li>\(x_{11}y_{11}   +x_{12}y_{12}+ x_{13}y_{13}\) 相当于\(testX * trainX\)</li>
</ul>
<p>于是就可以 <strong>broadcasting</strong> 啦</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">transXtrain = self.X_train.T <span class="comment"># 转置训练集</span></div><div class="line">sumX = np.sum(X ** <span class="number">2</span>, axis = <span class="number">1</span>)[:, np.newaxis] <span class="comment">#（500x1）</span></div><div class="line">sumtransXtrain = np.sum(transXtrain ** <span class="number">2</span>, axis = <span class="number">0</span>)[np.newaxis] <span class="comment">#（1x5000）</span></div><div class="line">dists = np.sqrt( sumX + sumtransXtrain - <span class="number">2</span> * np.dot(X, transXtrain)) <span class="comment"># broadcasting &amp; matrix multiplication</span></div></pre></td></tr></table></figure>
<p>最后一个部分是关于k-折交叉验证，根据作业提示，循环每个可能的k值，运行k-nn算法 num_folds 次，每次选择一个子集作为训练集，最后一个子集为验证集。但参考了网上关于10折交叉验证的说法，是轮流将其中9份作为训练数据，1份作为测试数据的。所以我就循环了num+folds-1次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">size = X_train_folds[<span class="number">0</span>].shape[<span class="number">0</span>]</div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_choices:</div><div class="line">    k_to_accuracies[k] = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_folds<span class="number">-1</span>): <span class="comment"># each case </span></div><div class="line">        classifier.train(X_train_folds[i], y_train_folds[i]) <span class="comment"># use one as training data</span></div><div class="line">        predict_labels = classifier.predict(X_train_folds[<span class="number">-1</span>], k, num_loops = <span class="number">0</span>)</div><div class="line">        accuracy = sum(predict_labels == y_train_folds[<span class="number">-1</span>]) / size <span class="comment"># last fold as validation set</span></div><div class="line">        k_to_accuracies[k].append(accuracy)</div></pre></td></tr></table></figure>
<p><img src="/2017/11/10/cs231n-assignment1/knn.png" alt="cross-validation"></p>
<p>最后根据交叉验证的结果选择k=8最佳。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/05/machine-learning-in-action-note5/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Colorjam</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>